---
rw_wire_assign_1_dim:
    rtl: |

        // Register-activation for '{path}' {alias}
        assign {path}_accss = b2r.addr == {addr};
        assign {path}_sw_wr = {path}_accss && b2r.r_vld;
        assign {path}_sw_rd = {path}_accss && b2r.w_vld;
    signals:
        - name: '{path}_sw_wr'
          signal_type: 'logic'
        - name: '{path}_sw_rd'
          signal_type: 'logic'
        - name: '{path}_accss'
          signal_type: 'logic'
rw_wire_assign_multi_dim: 
    rtl: |-

        // Register-activation for '{path}' {alias}
        assign {path}_accss{genvars} = b2r.addr == {addr}+({genvars_sum});
        assign {path}_sw_wr{genvars} = {path}_accss{genvars} && b2r.r_vld;
        assign {path}_sw_rd{genvars} = {path}_accss{genvars} && b2r.w_vld;
    signals:
        - name: '{path}_sw_wr'
          signal_type: 'logic'
        - name: '{path}_sw_rd'
          signal_type: 'logic'
        - name: '{path}_accss'
          signal_type: 'logic'
rw_wire_assign_any_alias: 
    rtl: |-

        // Combined register activation. These will become active 
        // _any_ alias accesses a certain register.
        assign {path}__any_alias_sw_wr{genvars} = {sw_wrs_w_genvars};
        assign {path}__any_alias_sw_rd{genvars} = {sw_rds_w_genvars};
    signals:
        - name: '{path}__any_alias_sw_wr'
          signal_type: 'logic'
        - name: '{path}__any_alias_sw_rd'
          signal_type: 'logic'
reg_comment: |-

    /*******************************************************************
     *******************************************************************
     * REGISTER              : {name}
     * DIMENSION             : {dimensions}
     * DEPTHS (per dimension): {depth}
     *******************************************************************
     *******************************************************************/
generate_for_start: |-
    for ({iterator} = 0; {iterator} < {limit}; {iterator}++)
    begin
generate_for_end: |-
    end // of for loop with iterator {dimension}
signal_declaration: |-
    {type:{signal_width}} {name:{name_width}}{unpacked_dim};
sw_data_assignment_var_name:
    rtl: |-
        {path}_data_mux_in
    signals:
        - name: '{path}_data_mux_in'
          signal_type: 'logic [{accesswidth}:0]'
sw_err_assignment_var_name:
    rtl: |-
        {path}_err_mux_in
    signals:
        - name: '{path}_err_mux_in'
          signal_type: 'logic'
sw_rdy_assignment_var_name:
    rtl: |-
        {path}_rdy_mux_in
    signals:
        - name: '{path}_rdy_mux_in'
          signal_type: 'logic'
sw_err_condition:
    rtl: |-
        !((b2r.r_vld && ({rd_byte_list_ored})) || (b2r.w_vld && ({wr_byte_list_ored})))
sw_data_assignment:
    rtl: |-
       /************************************** 
        * Assign all fields to signal to Mux *
        **************************************/
       // Assign all fields. Fields that are not readable are tied to 0.
       assign {sw_data_assignment_var_name}{genvars} = {{{list_of_fields}{genvars}}};

       // Internal registers are ready immediately
       assign {sw_rdy_assignment_var_name}{genvars} = {rdy_condition};

       // Return an error if *no* read and *no* write wa be succesful.
       // If some bits cannot be read/write but others are succesful, don't return
       // an error. Hence, as long as one action can be succesful, no error will be
       // returned.
       assign {sw_err_assignment_var_name}{genvars} = {err_condition};

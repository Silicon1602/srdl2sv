---
sense_list_rst:
    rtl: |-
        always_ff @(posedge reg_clk or {rst_edge} {rst_name})
sense_list_no_rst: 
    rtl: |-
        always_ff @(posedge reg_clk)
rst_field_assign: 
    rtl: |-
        if ({rst_negl}{rst_name})
        begin
        {path}_q{genvars} <= {rst_value};
        end
        else
    signals:
        - name: '{path}_q'
          signal_type: '{field_type}'
sw_access_field: 
    rtl: |-
        if ({path_wo_field}_sw_wr{genvars})
        begin
sw_access_field_swwe: 
    rtl: |-
        if ({path_wo_field}_sw_wr{genvars} && {swwe}) // swwe property
        begin
sw_access_field_swwel: 
    rtl: |-
        if ({path_wo_field}_sw_wr{genvars} && !{swwel}) // swwel property
        begin
sw_access_byte: 
    rtl: |-
        if (byte_enable[{i}])
        <<INDENT>>
        {path}_q{genvars}[{msb_field}:{lsb_field}] <= sw_wr_bus[{msb_bus}:{lsb_bus}];
        <<UNINDENT>>
    signals:
        - name: '{path}_q'
          signal_type: '{field_type}'
hw_enable_mask_start: 
    rtl: |-
        for (int idx = 0; idx < {width}; idx++)
        begin
        if ({negl}{signal}[idx])
        <<INDENT>>
hw_enable_mask_end: 
    rtl: |-
        <<UNINDENT>>
        end // for (int idx = 0; idx < {width}; idx++)
hw_access_we_wel: 
    rtl: |-
        if ({negl}{path}_hw_wr{genvars})
    input_ports:
        - name: '{path}_hw_wr'
          signal_type: '{field_type}'
hw_access_no_we_wel: 
    rtl: |-
        // we or wel property not set
hw_access_hwset:
    rtl: |-
        if ({path}_hwset{genvars})
        <<INDENT>>
        {enable_mask_start}
        {path}_q{genvars}{idx} <= {constant};
        {enable_mask_end}
        <<UNINDENT>>
    input_ports:
        - name: '{path}_hwset'
          signal_type: 'logic'
hw_access_hwclr:
    rtl: |-
        if ({path}_hwclr{genvars})
        <<INDENT>>
        {enable_mask_start}
        {path}_q{genvars}{idx} <= {constant};
        {enable_mask_end}
        <<UNINDENT>>
    input_ports:
        - name: '{path}_hwclr'
          signal_type: 'logic'
hw_access_field: 
    rtl: |-
        <<INDENT>>
        {enable_mask_start}
        {path}_q{genvars}{idx} <= {path}_in{genvars}{idx};
        {enable_mask_end}
        <<UNINDENT>>
    signals:
        - name: '{path}_q'
          signal_type: '{field_type}'
    input_ports:
        - name: '{path}_in'
          signal_type: '{field_type}'
hw_access_counter:
    rtl: |-
        if ({path}_incr{genvars} || {path}_decr{genvars})
        <<INDENT>>
        {enable_mask_start}
        {path}_q{genvars}{idx} <= {path}_next{genvars}{idx};
        {enable_mask_end}
        <<UNINDENT>>
    signals:
        - name: '{path}_update_cnt'
          signal_type: 'logic'
        - name: '{path}_next'
          signal_type: '{field_type}'
end_field_ff: 
    rtl: |-
        end // of {path}'s always_ff
OnWriteType.woset: 
    rtl: |-
        if (byte_enable[{i}]) // woset property
        begin
        {path}_q{genvars}[{msb_field}:{lsb_field}] <= {path}_q{genvars}[{msb_field}:{lsb_field}] | sw_wr_bus[{msb_bus}:{lsb_bus}];
        end
OnWriteType.woclr: 
    rtl: |-
        if (byte_enable[{i}]) // woclr property
        begin
        {path}_q{genvars}[{msb_field}:{lsb_field}] <= {path}_q{genvars}[{msb_field}:{lsb_field}] & ~sw_wr_bus[{msb_bus}:{lsb_bus}];
        end
OnWriteType.wot: 
    rtl: |-
        if (byte_enable[{i}]) // wot property
        begin
        {path}_q{genvars}[{msb_field}:{lsb_field}] <= {path}_q{genvars}[{msb_field}:{lsb_field}] ^ sw_wr_bus[{msb_bus}:{lsb_bus}];
        end
OnWriteType.wzs: 
    rtl: |-
        if (byte_enable[{i}]) // wzs property
        begin
        {path}_q{genvars}[{msb_field}:{lsb_field}] <= {path}_q{genvars}[{msb_field}:{lsb_field}] & sw_wr_bus[{msb_bus}:{lsb_bus}];
        end
OnWriteType.wzt: 
    rtl: |-
        if (byte_enable[{i}]) // wzt property
        begin
        {path}_q{genvars}[{msb_field}:{lsb_field}] <= {path}_q{genvars}[{msb_field}:{lsb_field}] ~^ sw_wr_bus[{msb_bus}:{lsb_bus}];
        end
OnWriteType.wclr: 
    rtl: |-
        {path}_q{genvars} <= {{{width}{{1'b0}}}};
OnWriteType.wset: 
    rtl: |-
        {path}_q{genvars} <= {{{width}{{1'b1}}}};
OnReadType.rclr: 
    rtl: |-
        if ({path_wo_field}_sw_rd{genvars}) // rclr property
        begin
        {path}_q{genvars} <= {{{width}{{1'b0}}}};
        end
OnReadType.rset: 
    rtl: |-
        if ({path_wo_field}_sw_rd{genvars}) // rset property
        begin
        {path}_q{genvars} <= {{{width}{{1'b1}}}};
        end

field_comment: 
    rtl: |-

        //-----------------FIELD SUMMARY-----------------
        // name       : {name} ({path_wo_field}[{msb}:{lsb}])
        // access     : hw = {hw_access} {hw_precedence} 
        //              sw = {sw_access} {sw_precedence}
        // reset      : {rst_active} / {rst_type}
        // flags      : {misc_flags}
        //-----------------------------------------------
combo_operation_comment: 
    rtl: |-

        // Combinational logic for {path}
assign_anded_operation: 
    rtl: |-
        assign {path}_anded{genvars} = {op_verilog}{path}_q{genvars};
    output_ports:
        - name: '{path}_anded'
          signal_type: 'logic'
assign_ored_operation: 
    rtl: |-
        assign {path}_ored{genvars} = {op_verilog}{path}_q{genvars};
    output_ports:
        - name: '{path}_ored'
          signal_type: 'logic'
assign_xored_operation: 
    rtl: |-
        assign {path}_xored{genvars} = {op_verilog}{path}_q{genvars};
    output_ports:
        - name: '{path}_xored'
          signal_type: 'logic'
singlepulse: 
    rtl: |-
        begin
        {path}{genvars}_q <= 0;
        end
out_port_assign: 
    rtl: |-

        // Connect register to hardware output port
        assign {path}_r{genvars} = {path}_q{genvars};
    output_ports:
        - name: '{path}_r'
          signal_type: '{field_type}'
swacc_assign:
    rtl: |-

        // Combinational block to generate swacc-output signals
        assign {path}_swacc{genvars} = ({path_wo_field}__any_alias_sw_wr{genvars} || {path_wo_field}__any_alias_sw_rd{genvars}) && |byte_enable[{msbyte}:{lsbyte}];
    output_ports:
        - name: '{path}_swacc'
          signal_type: 'logic'
swmod_always_comb:
    rtl: |-

        // Combinational block to generate swmod-output signals
        always_comb
        begin
        {path}_swmod{genvars}  = 0;
        {swmod_assigns}
        end
    output_ports:
        - name: '{path}_swmod'
          signal_type: 'logic'
swmod_assign: 
    rtl: |-
        {path}_swmod{genvars} |= {path_wo_field}__any_alias_sw_{rd_wr}{genvars} && |byte_enable[{msbyte}:{lsbyte}];
    output_ports:
        - name: '{path}_swmod'
          signal_type: 'logic'
counter_comment: 
    rtl: |-
      /***********************
       * Counter Combo Logic *
       ***********************/
counter: 
    rtl: |-

        // Combinational logic that implements counter
        // Note that the three branches for all three possibilities
        // are implemented but that either the _incr or the _decr value
        // might be tied to 0.
        always_comb
        begin
        {path}_next{genvars}  = {path}_q{genvars};

        if ({path}_incr{genvars} && {path}_decr{genvars})
        begin
        if (!{path}_incr_sat{genvars} && !{path}_decr_sat{genvars})
        begin
        {path}_next{genvars} += {path}_incr_val{genvars}; 
        {path}_next{genvars} -= {path}_decr_val{genvars}; 
        end
        end
        else if ({path}_incr{genvars})
        begin
        if (!{path}_incr_sat{genvars})
        <<INDENT>>
        {path}_next{genvars} += {path}_incr_val{genvars}; 
        <<UNINDENT>>
        end
        else if ({path}_decr{genvars})
        begin
        if (!{path}_decr_sat{genvars})
        <<INDENT>>
        {path}_next{genvars} += {path}_decr_val{genvars}; 
        <<UNINDENT>>
        end
        end
    signals:
        - name: '{path}_next'
          signal_type: '{field_type}'
counter_internal_incr_val_signal:
    rtl: |-
        assign {path}_incr_val{genvars} = {incr_value};
    signals:
        - name: '{path}_incr_val'
          signal_type: 'logic [{incr_width}:0]'
counter_internal_decr_val_signal:
    rtl: |-
        assign {path}_decr_val{genvars} = {decr_value};
    signals:
        - name: '{path}_decr_val'
          signal_type: 'logic [{decr_width}:0]'
counter_incr_val_input:
    rtl: ''
    input_ports:
        - name: '{path}_incr_val'
          signal_type: 'logic [{incr_width}:0]'
counter_decr_val_input:
    rtl: ''
    input_ports:
        - name: '{path}_decr_val'
          signal_type: 'logic [{decr_width}:0]'
counter_internal_incr_signal:
    rtl: |-
        assign {path}_incr{genvars} = {incr};
    signals:
        - name: '{path}_incr'
          signal_type: 'logic'
counter_internal_decr_signal:
    rtl: |-
        assign {path}_decr{genvars} = {decr};
    signals:
        - name: '{path}_decr'
          signal_type: 'logic'
counter_incr_input:
    rtl: ''
    input_ports:
        - name: '{path}_incr'
          signal_type: ''
counter_decr_input:
    rtl: ''
    input_ports:
        - name: '{path}_decr'
          signal_type: ''
counter_incr_sat:
    rtl: |-

        // Determine whether the counter is saturated
        // The signal is tied if the counter is not saturating
        // in the respective direction
        assign {path}_incr_sat{genvars} = {path}_q{genvars} + ({{{incr_width}{{{path}_incr}}}} & {path}_incr_val) - ({{{decr_width}{{{path}_decr}}}} & {path}_decr_val) > {sat_value};
    signals:
        - name: '{path}_incr_sat'
          signal_type: 'logic'
counter_incr_sat_tied:
    rtl: |-

        // Determine whether the counter is saturated
        // The signal is tied if the counter is not saturating
        // in the respective direction
        assign {path}_incr_sat{genvars} = 1'b0;
    signals:
        - name: '{path}_incr_sat'
          signal_type: 'logic'
counter_decr_sat:
    rtl: |-
        assign {path}_decr_sat{genvars} = {path}_q{genvars} + ({{{incr_width}{{{path}_incr}}}} & {path}_incr_val) - ({{{decr_width}{{{path}_decr}}}} & {path}_decr_val) > {sat_value};
    signals:
        - name: '{path}_decr_sat'
          signal_type: 'logic'
counter_decr_sat_tied:
    rtl: |-
        assign {path}_decr_sat{genvars} = 1'b0;
    signals:
        - name: '{path}_decr_sat'
          signal_type: 'logic'
counter_overflow:
    rtl: |-

        // Logic to determine occurance of an overflow
        assign {path}_overflow_int{genvars} = {path}_q{genvars} + ({{{incr_width}{{{path}_incr}}}} & {path}_incr_val) - ({{{decr_width}{{{path}_decr}}}} & {path}_decr_val) > {overflow_value};
        assign {path}_overflow{genvars} = {path}_incr{genvars} && {path}_overflow_int{genvars};
    signals:
        - name: '{path}_overflow_int'
          signal_type: 'logic'
    output_ports:
        - name: '{path}_overflow'
          signal_type: 'logic'
counter_underflow:
    rtl: |-

        // Logic to determine occurance of an underflow
        assign {path}_underflow_int{genvars} = {path}_q{genvars} + ({{{incr_width}{{{path}_incr}}}} & {path}_incr_val) - ({{{decr_width}{{{path}_decr}}}} & {path}_decr_val) > {underflow_value};
        assign {path}_underflow{genvars} = {path}_incr{genvars} && {path}_underflow_int{genvars};
    signals:
        - name: '{path}_underflow_int'
          signal_type: 'logic'
    output_ports:
        - name: '{path}_underflow'
          signal_type: 'logic'
